# [BOJ] 16935번 배열 돌리기 3 (CPP)


백준온라인저지(BOJ) https://www.acmicpc.net/problem/16935


아이디: song98987


## 1. 문제 설명

#### 문제
크기가 N×M인 배열이 있을 때, 배열에 연산을 R번 적용하려고 한다. 연산은 총 6가지가 있다.

1번 연산은 배열을 상하 반전시키는 연산이다.
```text
1 6 2 9 8 4 → 4 2 9 3 1 8
7 2 6 9 8 2 → 9 2 3 6 1 5
1 8 3 4 2 9 → 7 4 6 2 3 1
7 4 6 2 3 1 → 1 8 3 4 2 9
9 2 3 6 1 5 → 7 2 6 9 8 2
4 2 9 3 1 8 → 1 6 2 9 8 4
   <배열>       <연산 결과>
````
2번 연산은 배열을 좌우 반전시키는 연산이다.
```text
1 6 2 9 8 4 → 4 8 9 2 6 1
7 2 6 9 8 2 → 2 8 9 6 2 7
1 8 3 4 2 9 → 9 2 4 3 8 1
7 4 6 2 3 1 → 1 3 2 6 4 7
9 2 3 6 1 5 → 5 1 6 3 2 9
4 2 9 3 1 8 → 8 1 3 9 2 4
   <배열>       <연산 결과>
```
3번 연산은 오른쪽으로 90도 회전시키는 연산이다.
```text
1 6 2 9 8 4 → 4 9 7 1 7 1
7 2 6 9 8 2 → 2 2 4 8 2 6
1 8 3 4 2 9 → 9 3 6 3 6 2
7 4 6 2 3 1 → 3 6 2 4 9 9
9 2 3 6 1 5 → 1 1 3 2 8 8
4 2 9 3 1 8 → 8 5 1 9 2 4
   <배열>       <연산 결과>
```
4번 연산은 왼쪽으로 90도 회전시키는 연산이다.
```text
1 6 2 9 8 4 → 4 2 9 1 5 8
7 2 6 9 8 2 → 8 8 2 3 1 1
1 8 3 4 2 9 → 9 9 4 2 6 3
7 4 6 2 3 1 → 2 6 3 6 3 9
9 2 3 6 1 5 → 6 2 8 4 2 2
4 2 9 3 1 8 → 1 7 1 7 9 4
   <배열>       <연산 결과>
```
5, 6번 연산을 수행하려면 배열을 크기가 N/2×M/2인 4개의 부분 배열로 나눠야 한다. 아래 그림은 크기가 6×8인 배열을 4개의 그룹으로 나눈 것이고, 1부터 4까지의 수로 나타냈다.
```text
1 1 1 1 2 2 2 2
1 1 1 1 2 2 2 2
1 1 1 1 2 2 2 2
4 4 4 4 3 3 3 3
4 4 4 4 3 3 3 3
4 4 4 4 3 3 3 3
```
5번 연산은 1번 그룹의 부분 배열을 2번 그룹 위치로, 2번을 3번으로, 3번을 4번으로, 4번을 1번으로 이동시키는 연산이다.
```text
3 2 6 3 1 2 9 7 → 2 1 3 8 3 2 6 3
9 7 8 2 1 4 5 3 → 1 3 2 8 9 7 8 2
5 9 2 1 9 6 1 8 → 4 5 1 9 5 9 2 1
2 1 3 8 6 3 9 2 → 6 3 9 2 1 2 9 7
1 3 2 8 7 9 2 1 → 7 9 2 1 1 4 5 3
4 5 1 9 8 2 1 3 → 8 2 1 3 9 6 1 8
     <배열>            <연산 결과>
```
6번 연산은 1번 그룹의 부분 배열을 4번 그룹 위치로, 4번을 3번으로, 3번을 2번으로, 2번을 1번으로 이동시키는 연산이다.
```text
3 2 6 3 1 2 9 7 → 1 2 9 7 6 3 9 2
9 7 8 2 1 4 5 3 → 1 4 5 3 7 9 2 1
5 9 2 1 9 6 1 8 → 9 6 1 8 8 2 1 3
2 1 3 8 6 3 9 2 → 3 2 6 3 2 1 3 8
1 3 2 8 7 9 2 1 → 9 7 8 2 1 3 2 8
4 5 1 9 8 2 1 3 → 5 9 2 1 4 5 1 9
     <배열>            <연산 결과>
```

#### 입력

첫째 줄에 배열의 크기 N, M과 수행해야 하는 연산의 수 R이 주어진다.

둘째 줄부터 N개의 줄에 배열 A의 원소 Aij가 주어진다.

마지막 줄에는 수행해야 하는 연산이 주어진다. 연산은 공백으로 구분되어져 있고, 문제에서 설명한 연산 번호이며, 순서대로 적용시켜야 한다.

#### 출력
입력으로 주어진 배열에 R개의 연산을 순서대로 수행한 결과를 출력한다.

## 2. 내 소스 코드

```c++
#include <bits/stdc++.h>
using namespace std;

int n, m, r, a[101][101];

void r1() {
    // 상하반전
    for (int i=0; i<n/2; i++) {
        for (int j=0; j<m; j++) {
            swap(a[i][j], a[n-i-1][j]);
        }
    }
}

void r2() {
    // 좌우반전
    for (int i=0; i<n; i++) {
        for (int j=0; j<m/2; j++) {
            swap(a[i][j], a[i][m-j-1]);
        }
    }
}

void r3() {
    // 90도 오른쪽 회전
    int p[4];
    int d[101][101];

    for (int i=0; i<n/2; i++) {
        for (int j=0; j<m/2; j++) {
            p[0] = a[i][j];
            p[1] = a[i][m-j-1];
            p[2] = a[n-i-1][m-j-1];
            p[3] = a[n-i-1][j];
            
            d[j][n-i-1] = p[0];
            d[m-j-1][n-i-1] = p[1];
            d[m-j-1][i] = p[2];
            d[j][i] = p[3];
        }
    }

    swap(n, m);

    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            a[i][j] = d[i][j];
        }
    }
}

void r4() {
    // 90도 왼쪽으로 회전
    int p[4];
    int d[101][101];

    for (int i=0; i<n/2; i++) {
        for (int j=0; j<m/2; j++) {
            p[0] = a[i][j];
            p[1] = a[i][m-j-1];
            p[2] = a[n-i-1][m-j-1];
            p[3] = a[n-i-1][j];
            
            d[m-j-1][i] = p[0];
            d[j][i] = p[1];
            d[j][n-i-1] = p[2];
            d[m-j-1][n-i-1] = p[3];
        }
    }

    swap(n, m);

    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            a[i][j] = d[i][j];
        }
    }
}

void r5() {
    // 1->2->3->4->1
    int swap[4];

    for (int i=0; i<n/2; i++) {
        for (int j=0; j<m/2; j++) {
            swap[0] = a[i][j];
            swap[1] = a[i][m/2+j];
            swap[2] = a[n/2+i][m/2+j];
            swap[3] = a[n/2+i][j];
            
            a[i][m/2+j] = swap[0];
            a[n/2+i][m/2+j] = swap[1];
            a[n/2+i][j] = swap[2];
            a[i][j] = swap[3];
        }
    }
}

void r6() {
    // 1->4->3->2->1
    int swap[4];

    for (int i=0; i<n/2; i++) {
        for (int j=0; j<m/2; j++) {
            swap[0] = a[i][j];
            swap[1] = a[i][m/2+j];
            swap[2] = a[n/2+i][m/2+j];
            swap[3] = a[n/2+i][j];
            
            a[n/2+i][j] = swap[0];
            a[i][j] = swap[1];
            a[i][m/2+j] = swap[2];
            a[n/2+i][m/2+j] = swap[3];
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> n >> m >> r;

    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            cin >> a[i][j];
        }
    }

    int input;
    while (r--) {
        cin >> input;

        switch(input) {
        case 1:
            r1();
            break;
        case 2:
            r2();
            break;
        case 3:
            r3();
            break;
        case 4:
            r4();
            break;
        case 5:
            r5();
            break;
        case 6:
            r6();
            break;
        }
    }

    for (int i=0; i<n; i++) {
        for (int j=0; j<m; j++) {
            cout << a[i][j] << " ";
        }
        cout << "\n";
    }
}
```

## 3. 개선점

