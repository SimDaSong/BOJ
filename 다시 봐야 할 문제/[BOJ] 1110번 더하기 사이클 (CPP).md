# [BOJ] 1110번  더하기 사이클 (CPP)

백준온라인저지(BOJ) https://www.acmicpc.net/problem/1110

아이디: song98987



## 1. 문제 설명

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 2 초      | 128 MB      | 43515 | 21450 | 18380     | 50.460%   |

#### 문제

0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자.

26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다.

위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다.

N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.

#### 입력

첫째 줄에 N이 주어진다. N은 0보다 크거나 같고, 99보다 작거나 같은 정수이다.

#### 출력

첫째 줄에 N의 사이클 길이를 출력한다.



#### 예제 입력 1

```
26
```

#### 예제 출력 1

```
4
```

#### 예제 입력 2

```
55
```

#### 예제 출력 2

```
3
```

#### 예제 입력 3

```
1
```

#### 예제 출력 3

```
60
```



## 2. 내 소스 코드

```C++
#include <iostream>

int main() {
	int n, new_n; // 입력 받을 정수와 새로운 수
	int cycle = 0; // 사이클의 길이
	
	// 정수 입력 받기
	scanf("%d", &n);

	// 새로운 수 만들기
	new_n = n;
	do {
		new_n = (new_n % 10) * 10 + (((new_n / 10) + (new_n % 10)) % 10); // (십의 자리 수)*10 + (일의 자리 수)
																		  // new_n 대신에 n을 넣으면 당연히 안되지!
		cycle++;
	} while (n != new_n);

	printf("%d", cycle);
}
```

배열로 하려고 했었는데 삽질이었다!



## 3. 개선점

1. 사실 코드의 가독성이 떨어지는 것은 사실. 아래의 코드처럼 함수로 작성하면 가독성이 올라간다!

```C++
#include <iostream>
using namespace std;
int nextNumber(int n) {
    int p = n / 10;
    int q = n % 10;
    return 10*q + (p+q)%10;
}
int main() {
    int N;
    scanf("%d", &N);
    int num = N;
    int count = 0;
    while(true) {
        count++;
        num = nextNumber(num);
        if( num == N ) break;
    }
    printf("%d", count);
}
```

[https://zetawiki.com/wiki/BOJ_1110_%EB%8D%94%ED%95%98%EA%B8%B0_%EC%82%AC%EC%9D%B4%ED%81%B4](https://zetawiki.com/wiki/BOJ_1110_더하기_사이클)

2. 배열로 풀려고 했다가 이러한 방법은 비효율적임을 깨달았다. 알고리즘 문제를 풀 때 항상 배열로 풀어야겠다는 생각을 하는 듯 하다 ㅠㅠ 다른 방법이 많은데도 불구하고